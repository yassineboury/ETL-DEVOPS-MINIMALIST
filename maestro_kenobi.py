#!/usr/bin/env python3
"""
üéØ MAESTRO KENOBI - ETL DevSecOps Orchestrator
Le ma√Ætre orchestrateur pour les exports GitLab et DevSecOps
G√®re les exports selon un processus clair et par √©tapes avec style !
"""

import contextlib
import sys
import time
from datetime import datetime
from pathlib import Path

from dotenv import load_dotenv
from tqdm import tqdm

# Ajouter les dossiers au path
project_root = Path(__file__).parent
sys.path.insert(0, str(project_root))

from gitlab_tools.client.gitlab_client import create_gitlab_client
from gitlab_tools.exporters.excel_exporter import (
    export_projects_to_excel,
    export_users_to_excel,
    export_groups_to_excel,
)
from gitlab_tools.extractors.projects_extractor import extract_projects
from gitlab_tools.extractors.users_extractor import extract_human_users
from gitlab_tools.extractors.groups_extractor import GroupsExtractor


class MaestroKenobiOrchestrator:
    """
    üé≠ MAESTRO KENOBI - Le ma√Ætre orchestrateur GitLab
    G√®re les exports GitLab avec √©l√©gance et puissance
    """

    # Messages constants
    NO_GITLAB_CONNECTION = "‚ùå Pas de connexion GitLab active"

    def __init__(self):
        self.project_root = Path(__file__).parent
        self.exports_dir = self.project_root / "exports" / "gitlab"
        self.gitlab_client = None
        self.gl = None

        # Configuration de la barre de progression
        self.total_steps = 7  # Ajout de l'√©tape groupes
        self.current_step = 0
        self.main_progress = None

    def _update_progress(self, description: str):
        """
        Met √† jour la barre de progression principale

        Args:
            description: Description de l'√©tape en cours
        """
        if self.main_progress:
            self.main_progress.set_description(f"üìä {description}")
            self.main_progress.update(1)
            time.sleep(0.1)  # Petit d√©lai pour voir la progression

    def step_1_cleanup_old_files(self) -> bool:
        """
        √âtape 1: Supprimer les anciens fichiers du dossier exports/gitlab

        Returns:
            bool: True si succ√®s, False sinon
        """
        print("üßπ √âTAPE 1: Nettoyage des anciens fichiers d'export")
        print("-" * 50)

        try:
            if not self.exports_dir.exists():
                print("üìÅ Le dossier exports/gitlab n'existe pas encore")
                self._update_progress("Nettoyage termin√© (aucun fichier)")
                return True

            # Lister les fichiers existants
            existing_files = list(self.exports_dir.glob("*.xlsx"))

            if not existing_files:
                print("‚úÖ Aucun ancien fichier √† supprimer")
                self._update_progress("Nettoyage termin√© (aucun fichier)")
                return True

            print(f"üìã {len(existing_files)} fichier(s) trouv√©(s):")
            for file in existing_files:
                print(f"   ‚Ä¢ {file.name}")

            # Supprimer les fichiers avec barre de progression
            deleted_count = 0
            with tqdm(
                total=len(existing_files),
                desc="üóëÔ∏è  Suppression",
                unit="fichier",
                leave=False
            ) as pbar:
                for file in existing_files:
                    try:
                        file.unlink()
                        print(f"   ‚úÖ Supprim√©: {file.name}")
                        deleted_count += 1
                        pbar.update(1)
                        time.sleep(0.1)  # Simulation du temps de suppression
                    except Exception as e:
                        print(f"   ‚ùå Erreur suppression {file.name}: {e}")
                        pbar.update(1)

            print(f"üóëÔ∏è  {deleted_count} fichier(s) supprim√©(s)")
            print("‚úÖ √âtape 1 termin√©e avec succ√®s")
            self._update_progress(f"Nettoyage termin√© ({deleted_count} fichiers)")
            return True

        except Exception as e:
            print(f"‚ùå Erreur lors du nettoyage: {e}")
            self._update_progress("Erreur nettoyage")
            return False

    def step_2_connect_gitlab(self) -> bool:
        """
        √âtape 2: Connexion √† GitLab ONCF

        Returns:
            bool: True si succ√®s, False sinon
        """
        print("\nüîó √âTAPE 2: Connexion √† GitLab ONCF")
        print("-" * 50)

        try:
            # Charger les variables d'environnement
            load_dotenv()

            # Cr√©er le client GitLab
            print("üîë Cr√©ation du client GitLab...")
            self.gitlab_client = create_gitlab_client()

            # Se connecter
            print("üåê Connexion √† GitLab ONCF...")
            self.gl = self.gitlab_client.connect()

            if not self.gl:
                print("‚ùå Impossible de se connecter √† GitLab")
                return False

            print("‚úÖ Connexion GitLab √©tablie avec succ√®s")
            self._update_progress("Connexion GitLab √©tablie")
            return True

        except Exception as e:
            print(f"‚ùå Erreur lors de la connexion: {e}")
            self._update_progress("Erreur connexion GitLab")
            return False

    def step_3_extract_users(self) -> tuple[bool, int]:
        """
        √âtape 3: Extraction des utilisateurs GitLab

        Returns:
            tuple: (succ√®s, nombre d'utilisateurs)
        """
        print("\nüë• √âTAPE 3: Extraction des utilisateurs GitLab")
        print("-" * 50)

        try:
            if not self.gl:
                print(self.NO_GITLAB_CONNECTION)
                return False, 0

            # Extraire les utilisateurs humains
            users_df = extract_human_users(self.gl, include_blocked=True)

            if users_df.empty:
                print("‚ùå Aucun utilisateur trouv√©")
                return False, 0

            user_count = len(users_df)
            print(f"‚úÖ {user_count} utilisateurs humains extraits")

            # Statistiques rapides
            if 'etat' in users_df.columns:
                states = users_df['etat'].value_counts()
                print(f"üìä √âtats: {states.to_dict()}")

            # Sauvegarder temporairement
            self.users_data = users_df
            self._update_progress(f"Extraction utilisateurs ({user_count})")
            return True, user_count

        except Exception as e:
            print(f"‚ùå Erreur lors de l'extraction des utilisateurs: {e}")
            self._update_progress("Erreur extraction utilisateurs")
            return False, 0

    def step_4_extract_groups(self) -> tuple[bool, int]:
        """
        √âtape 4: Extraction des groupes GitLab

        Returns:
            tuple: (succ√®s, nombre de groupes)
        """
        print("\nüë• √âTAPE 4: Extraction des groupes GitLab")
        print("-" * 50)

        try:
            if not self.gl:
                print(self.NO_GITLAB_CONNECTION)
                return False, 0

            # Cr√©er l'extracteur de groupes
            groups_extractor = GroupsExtractor(self.gl)
            
            # Extraire les groupes
            groups_df = groups_extractor.extract()

            if groups_df.empty:
                print("‚ùå Aucun groupe trouv√©")
                return False, 0

            groups_count = len(groups_df)
            print(f"‚úÖ {groups_count} groupes extraits")

            # Statistiques rapides
            if 'is_top_level' in groups_df.columns:
                top_level_count = groups_df['is_top_level'].sum()
                sub_groups_count = groups_count - top_level_count
                print(f"üìä Groupes racine: {top_level_count}, Sous-groupes: {sub_groups_count}")

            if 'total_members' in groups_df.columns:
                total_members = groups_df['total_members'].sum()
                print(f"üë• Total membres: {total_members}")

            # Sauvegarder temporairement
            self.groups_data = groups_df
            self._update_progress(f"Extraction groupes ({groups_count})")
            return True, groups_count

        except Exception as e:
            print(f"‚ùå Erreur lors de l'extraction des groupes: {e}")
            self._update_progress("Erreur extraction groupes")
            return False, 0

    def step_5_extract_projects(self) -> tuple[bool, int]:
        """
        √âtape 5: Extraction des projets GitLab

        Returns:
            tuple: (succ√®s, nombre de projets)
        """
        print("\nüìÅ √âTAPE 5: Extraction des projets GitLab")
        print("-" * 50)

        try:
            if not self.gl:
                print(self.NO_GITLAB_CONNECTION)
                return False, 0

            # Extraire tous les projets (actifs + archiv√©s)
            projects_df = extract_projects(self.gl, include_archived=True)

            if projects_df.empty:
                print("‚ùå Aucun projet trouv√©")
                return False, 0

            project_count = len(projects_df)
            print(f"‚úÖ {project_count} projets extraits")

            # Statistiques rapides
            if 'etat' in projects_df.columns:
                states = projects_df['etat'].value_counts()
                print(f"üìä √âtats: {states.to_dict()}")

            if 'archiv√©' in projects_df.columns:
                archived = projects_df['archiv√©'].value_counts()
                print(f"üì¶ Archivage: {archived.to_dict()}")

            # Sauvegarder temporairement
            self.projects_data = projects_df
            self._update_progress(f"Extraction projets ({project_count})")
            return True, project_count

        except Exception as e:
            print(f"‚ùå Erreur lors de l'extraction des projets: {e}")
            self._update_progress("Erreur extraction projets")
            return False, 0

    def step_6_export_to_excel(self) -> tuple[bool, list]:
        """
        √âtape 6: Export des donn√©es vers Excel

        Returns:
            tuple: (succ√®s, liste des fichiers cr√©√©s)
        """
        print("\nüìä √âTAPE 6: Export vers fichiers Excel")
        print("-" * 50)

        try:
            required_data = ['users_data', 'projects_data', 'groups_data']
            missing_data = [data for data in required_data if not hasattr(self, data)]
            
            if missing_data:
                print(f"‚ùå Donn√©es manquantes pour l'export: {', '.join(missing_data)}")
                return False, []

            created_files = []

            # Barre de progression pour l'export
            export_tasks = ["utilisateurs", "groupes", "projets"]
            with tqdm(
                total=len(export_tasks),
                desc="üìÅ Export Excel",
                unit="fichier",
                leave=False
            ) as pbar:

                # Export des utilisateurs
                print("üë• Export des utilisateurs...")
                pbar.set_description("üìÅ Export utilisateurs")
                users_file = export_users_to_excel(
                    self.users_data,
                    filename="gitlab_users.xlsx"
                )
                if users_file:
                    created_files.append(users_file)
                    print(f"   ‚úÖ Utilisateurs: {Path(users_file).name}")
                pbar.update(1)

                # Export des groupes  
                print("üë• Export des groupes...")
                pbar.set_description("üìÅ Export groupes")
                groups_file = export_groups_to_excel(
                    self.groups_data,
                    filename="gitlab_groups.xlsx"
                )
                if groups_file:
                    created_files.append(groups_file)
                    print(f"   ‚úÖ Groupes: {Path(groups_file).name}")
                pbar.update(1)
                time.sleep(0.2)

                # Export des projets
                print("üìÅ Export des projets...")
                pbar.set_description("üìÅ Export projets")
                projects_file = export_projects_to_excel(
                    self.projects_data,
                    filename="gitlab_projects.xlsx"
                )
                if projects_file:
                    created_files.append(projects_file)
                    print(f"   ‚úÖ Projets: {Path(projects_file).name}")
                pbar.update(1)
                time.sleep(0.2)

            if created_files:
                print(f"‚úÖ {len(created_files)} fichier(s) Excel cr√©√©(s)")
                self._update_progress(f"Export Excel ({len(created_files)} fichiers)")
                return True, created_files
            else:
                print("‚ùå Aucun fichier cr√©√©")
                self._update_progress("Erreur export Excel")
                return False, []

        except Exception as e:
            print(f"‚ùå Erreur lors de l'export Excel: {e}")
            self._update_progress("Erreur export Excel")
            return False, []

    def step_7_cleanup_and_summary(
        self, users_count: int, projects_count: int, groups_count: int, created_files: list
    ) -> bool:
        """
        √âtape 7: Nettoyage final et r√©sum√©

        Args:
            users_count: Nombre d'utilisateurs extraits
            projects_count: Nombre de projets extraits  
            groups_count: Nombre de groupes extraits
            created_files: Liste des fichiers cr√©√©s

        Returns:
            bool: True si succ√®s
        """
        print("\nüßπ √âTAPE 7: Nettoyage final et r√©sum√©")
        print("-" * 50)

        try:
            # Fermer la connexion GitLab
            if self.gitlab_client:
                self.gitlab_client.disconnect()
                print("üîå Connexion GitLab ferm√©e")

            # Nettoyer les donn√©es temporaires
            if hasattr(self, 'users_data'):
                delattr(self, 'users_data')
            if hasattr(self, 'projects_data'):
                delattr(self, 'projects_data')
            if hasattr(self, 'groups_data'):
                delattr(self, 'groups_data')

            print("üóëÔ∏è  Donn√©es temporaires nettoy√©es")

            # R√©sum√© final
            print("\n" + "=" * 60)
            print("üéâ EXPORT GITLAB TERMIN√â AVEC SUCC√àS!")
            print("=" * 60)
            print(f"üë• Utilisateurs extraits: {users_count}")
            print(f"üë• Groupes extraits: {groups_count}")
            print(f"üìÅ Projets extraits: {projects_count}")
            print("=" * 60)
            print(f"üë• Utilisateurs extraits: {users_count}")
            print(f"üìÅ Projets extraits: {projects_count}")
            print(f"üìä Fichiers Excel cr√©√©s: {len(created_files)}")

            if created_files:
                print("\nüìÅ Fichiers g√©n√©r√©s:")
                for file_path in created_files:
                    file_size = Path(file_path).stat().st_size / 1024  # KB
                    print(f"   ‚úÖ {Path(file_path).name} ({file_size:.1f} KB)")

                print(f"\nüìÇ Dossier: {self.exports_dir}")

            print(f"\n‚è∞ Export termin√© le: {datetime.now().strftime('%d/%m/%Y √† %H:%M:%S')}")

            self._update_progress("Nettoyage et r√©sum√© termin√©s")
            return True

        except Exception as e:
            print(f"‚ùå Erreur lors du nettoyage: {e}")
            self._update_progress("Erreur nettoyage final")
            return False

    def run_full_export(self) -> bool:
        """
        Lance l'export complet en suivant toutes les √©tapes

        Returns:
            bool: True si tout s'est bien pass√©
        """
        print("üöÄ KENOBI DEVOPS - ORCHESTRATEUR D'EXPORT GITLAB")
        print("=" * 60)
        print(f"üìÖ D√©marrage le: {datetime.now().strftime('%d/%m/%Y √† %H:%M:%S')}")
        print("=" * 60)

        # Initialiser la barre de progression principale
        with tqdm(
            total=self.total_steps,
            desc="üîÑ √âtapes d'export",
            unit="√©tape",
            bar_format="{desc}: {percentage:3.0f}%|{bar}| {n_fmt}/{total_fmt} √©tapes [{elapsed}<{remaining}]"
        ) as progress:

            self.main_progress = progress

            try:
                # √âtape 1: Nettoyage
                if not self.step_1_cleanup_old_files():
                    return False

                # √âtape 2: Connexion
                if not self.step_2_connect_gitlab():
                    return False

                # √âtape 3: Extraction utilisateurs
                users_success, users_count = self.step_3_extract_users()
                if not users_success:
                    return False

                # √âtape 4: Extraction groupes
                groups_success, groups_count = self.step_4_extract_groups()
                if not groups_success:
                    return False

                # √âtape 5: Extraction projets
                projects_success, projects_count = self.step_5_extract_projects()
                if not projects_success:
                    return False

                # √âtape 6: Export Excel
                export_success, created_files = self.step_6_export_to_excel()
                if not export_success:
                    return False

                # √âtape 7: Nettoyage et r√©sum√©
                if not self.step_7_cleanup_and_summary(users_count, projects_count, groups_count, created_files):
                    return False

                # Finaliser la barre de progression
                progress.set_description("üéâ Export termin√©")
                progress.refresh()

                return True

            except Exception as e:
                print(f"\n‚ùå ERREUR CRITIQUE: {e}")
                progress.set_description("‚ùå Erreur critique")
                # Nettoyage d'urgence
                if self.gitlab_client:
                    with contextlib.suppress(Exception):
                        self.gitlab_client.disconnect()
                return False
            finally:
                self.main_progress = None


def main():
    """üöÄ Point d'entr√©e principal - MAESTRO KENOBI en action !"""
    print("üé≠ MAESTRO KENOBI - Orchestrateur DevSecOps")
    print("=" * 50)

    orchestrator = MaestroKenobiOrchestrator()

    # Lancer l'export complet
    success = orchestrator.run_full_export()

    return success


if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)
